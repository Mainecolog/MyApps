

// Свойство target интерфейса Event является ссылкой на объект, который был инициатором события. Он отличается от Event.currentTarget, если обработчик события вызывается во время всплытия (bubbling) или захвата события.

// Для иллюстрации делегирования событий рассмотрим пример HTML-документа:

// <!DOCTYPE html>
// <html>
//     <head>
//         <title>Пример документа</title>
//     </head>
//     <body>
//         <div>
//             <p>Первый абзац</p>
//             <p>Второй абзац</p>
//             <p>Третий абзац</p>
//         </div>
//     </body>
// </html>
// Представьте, что для каждого элемента внутри <div> нам нужно добавить обработку какого-то события, например click. Для этого придется выбрать все элементы и добавить для каждого свой обработчик. Хорошо, что у нас всего три элемента <p>, однако если их 100 или 1000? В таком случае нам пригодится делегирование событий.

// Делегирование события заключается в том, что вместо добавления однотипных обработчиков события для каждого элемента, мы добавляем один обработчик для родительского элемента.

// Например, добавим обработчик события click для элемента <div>:

const div = document.querySelector("div");
div.addEventListener("click", (event) => {
  const p = event.target.closest("p");
  if (p) {
    p.style.color = "red";
  }
});
// Найти элемент, по которому сделан клик можно с помощью event.target. Если нужный элемент найден, можно выполнить необходимые действия с ним.
// Делегирование событий возможно благодаря технологии распространения событий, которую мы рассмотрели чуть раньше.

// Итоги
// В этом уроке мы познакомились с понятием DOM-дерева и с тем, как работать с его элементами: как находить элементы в документе, создавать новые и изменять существующие.
// Также были рассмотрены основные виды событий и особенности работы с ними.