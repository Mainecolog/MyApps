// // Замыкания
// const creatMultiplyer = function(n) 
// {
// return function()   {
//     return n*10;
// }
// }
// const multiply = creatMultiplyer(5);
// const result = multiply();
// console.log(result);
// const creatCounter = (initialValue = 0) => 
// {
//     return (valueToAdd) => {
//         return  valueToAdd+initialValue;
//     }
// }
// const addFive = creatCounter(5);
// const result = addFive(1);
// console.log(result);
// То есть: 
// 1.Мы задаем функцию с переменной;
// 2.Внутрь функции помещаем еще одну функцию уже со своей переменной;
// 3. ПОлучается, что внешняя функция замыкается по внутренней.
// 4. ПОтом мы, присываевая значение переменной дял внешней функции
// задаем новую функцию(даем название) для внутренней функции.
// 5. Вызывая внутренюю функцию, мы присваеваем ей переменную.Внутрь
// функция внтр = функция внешняя (переменная внешняя)
// функция результат = внутренняя функция (переменная внутренняя).
// в консоле выводим результат и получаем внешнюю функцию по внутренней!
const creatCounter = (initialValue = 0) => 
{   let counter = initialValue;
        return (valueToAdd) => {
            counter += valueToAdd;
            return counter;
        }
}
const addTwo = creatCounter(2);
let result = addTwo(10); // 12
result = addTwo(5); // 17
result = addTwo(2); // 19
console.log(result);
// Важно понимать, что переменная сохраняется между вызовами. 
// Если мы продолжим вызывать внутренню функцию, то предыдущие значения сохранятются


// Перед рассмотрением понятия замыкания, разберём связанную важную тему — область видимости переменных.

// Область видимости переменных

// Чтобы разобраться с понятием замыкания, сначала рассмотрим понятие области видимости переменных. На самом верхнем уровне, можно выделить 2 типа областей видимости — глобальная и локальная.

// Глобальная область видимости позволяет переменной быть видимой из любой точки кода. Переменная считается глобальной, когда она объявлена вне функций и блоков:

// const x = 10; // Глобальная переменная

// function show() {
//   console.log(x); // Выведет 10
// }
// В данном примере, внутри функции show() нет переменной с именем x. Однако это не помешает функции вывести в консоль значение переменной, т.к. она глобальная.

// Локальная область видимости ограничивает видимость переменной тем блоком кода, где она объявлена. Можно разделить локальную область видимости на три типа:

// Блочная — область видимости ограничена блоком кода (т.е. фигурными скобками { и }):
// if (true) {
//   const x = 10;
// }
// console.log(x); // Ошибка ReferenceError: x is not defined
// Так как переменная x определена внутри блока if, она доступна только внутри него. Поэтому попытка обращения к ней вне этого блока приведет к ошибке.

// Исключение — переменные, объявленные с помощью var. Они не имеют блочной области видимости и доступны даже вне блока, в котором объявлены. Напомним, что применение таких переменных не рекомендуется.

// Область видимости функции — ограничена функцией, в которой объявлена переменная:
// function test() {
//   const x = 10;
// }
// console.log(x); // Ошибка ReferenceError: x is not defined
// Здесь логика аналогична блочному типу. Объявленные внутри функции переменные доступны только внутри этой функции (включая все вложенные блоки кода и функции).

// Модульная — область видимости ограничена модулем. О модулях мы поговорим в будущих уроках.
// Цепочка областей видимости

// Области видимости могут быть вложены одна в другую, образуя цепочку. Рассмотрим это на примере:

// const x = 10;

// function show() {
//   const y = 20;

//   if (true) {
//     const z = 30;
//     console.log(x + y + z);
//   }
// }

// show(); // Выведет в консоль 60
// В данном примере функция show() выводит в консоль сумму трёх переменных. При обращении к переменной x, движок JavaScript действует по такому алгоритму:

// Пытается найти переменную с именем x внутри блока if. Не найдя её, переходит к родительскому блоку наверх.
// Пытается найти переменную x в функции show(). Не найдя её, переходит к глобальному контексту.
// Находит глобальную переменную x и использует её значение.
// Аналогичным образом находятся значения переменных y (она объявлена в функции) и z (объявлена в блоке if).

// Визуально области видимости для данного примера можно изобразить так:


// При этом, если во внутреннем блоке уже найдена переменная с нужным именем, поиск останавливается:

// const x = 10;

// if (true) {
//   const x = 20;
//   console.log(x); // Выведет 20
// }

// console.log(x); // Выведет 10
// Обратите внимание, что поиск переменной происходит только в одном направлении — изнутри наружу, то есть от внутренних блоков кода к внешним, в которые они вложены:


// Замыкание

// Лексическое окружение функции — простыми словами, это совокупность всех переменных, доступных из текущей области видимости. В него входят как локальные переменные, так и переменные из внешних областей видимости, вплоть до глобальных переменных.

// Замыкание — способность функции запоминать (захватывать / замыкать) лексическое окружение, в котором она была определена. На самом деле, все функции в JavaScript являются замыканиями, но на практике понимание этого механизма нужно прежде всего для случая с вложенными функциями, который мы рассмотрим далее.

// Пример замыкания со вложенной функцией:

// function outer() {
//   let x = 1;

//   function inner() {
//     console.log(x);
//     x++;
//   }

//   return inner;
// }

// const func = outer();
// func(); // Выведет в консоль: 1
// func(); // Выведет в консоль: 2
// Разберем этот код по пунктам:

// Внешняя функция outer() содержит определение переменной x и внутренней функции inner(). В качестве результата возвращается функция inner().
// Внутренняя функция inner() увеличивает значение переменной x и выводит его в консоль.
// Далее создается переменная func, которая содержит в себе результат работы функции outer. По сути, переменная func содержит функцию inner().
// Запускается функция func() два раза. В первом случае она выводит результат 1, во втором — 2.
// Когда создается функция inner(), она запоминает своё лексическое окружение. В данном случае, это переменная x из внешней функции. Соответственно, при повторном вызове функций, значение x увеличивается на 1.

// Важный нюанс заключается в том, что лексическое окружение запоминается каждый раз при определении функции. Это означает, что если создать ещё одну переменную и присвоить ей результат функции outer(), лексическое окружение для функции inner() будет захвачено заново. Соответственно, переменная x будет иметь начальное значение 1:

// // Опустим определение функции outer

// const func = outer();
// func(); // Выведет 1
// func(); // Выведет 2

// const func2 = outer();
// func2(); // Выведет 1
// Обрати внимание, что для второй функции func2() значение переменной x обнулилось и на консоль было выведено начальное значение 1.