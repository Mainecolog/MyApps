// Полиморфизм
// Одно действие и несколько реализаций.
class Animal {
    constructor(name){
        this.name = name;
    };
    makesound(){}
};

class Dog extends Animal {
    constructor(name){
        super(name);
    };
    makesound(){
        console.log(`Гав-Гав`);
    };
};

class Horse extends Animal{
constructor(name){
    super(name);
    };
makesound(){
    console.log(`И-го-го`);
    };
};


// Вообще полиморфизм означает «множество форм». С ним мы уже частично сталкивались, когда разбирали наследование и переопределяли метод move() в дочерних классах. Существует множество определений, но, проще говоря, это способность вызвать один и тот же метод у разных объектов, и при этом они могут выполнять разные действия. То есть одинаковым будет только имя метода, его реализация будет зависеть от класса. Посмотрим на примере:

// class Animal {
//   constructor(name) {
//     this.name = name;
//   }

//   makeSound() {}
// };

// class Cat extends Animal {
//   constructor(name) {
//     super(name);
//   }

//   makeSound() {
//     console.log('Мяу');
//   }
// }

// class Dog extends Animal {
//   // Примечание: Если конструктор просто вызывает родительский 
//   // со всеми переданными параметрами, то его можно не определять

//   makeSound() {
//     console.log('Гав');
//   }
// }

// const cat = new Cat('Мурзик');
// cat.makeSound(); // Мяу

// const dog = new Dog('Бобик');
// dog.makeSound(); // Гав
// Мы видим, что метод makeSound() при вызове для разных типов классов у объектов возвращает разные результаты. Действительно, классы Dog и Cat разные, но оба они наследуются от Animal. Благодаря полиморфизму, мы можем использовать объект, не зная какой это конкретно объект:

// const animals = [cat, dog];

// animals.forEach(animal => {
//   // вызываем метод для разных объектов
//   animal.makeSound(); 
// });

// // Выведет:
// // Мяу
// // Гав
// В данном примере мы работаем с объектом animal, у которого метод makeSound() работает по разному. В массиве у нас 2 разных типа объекта, но метод работает для каждого из них. Наша реализация полиморфна. 